<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
        }
        button {
            background: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .output {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            min-height: 100px;
        }
        .label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }
        .file-upload {
            margin-bottom: 20px;
            padding: 20px;
            border: 2px dashed #007bff;
            border-radius: 10px;
            background: #f8f9fa;
            text-align: center;
        }
        .file-upload:hover {
            background: #e9ecef;
        }
        .file-input {
            margin: 10px 0;
        }
        .file-info {
            margin: 10px 0;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 5px;
            font-size: 14px;
        }
        abbr {
            text-decoration: underline;
            text-decoration-style: dotted;
        }
        .processing {
            color: #007bff;
            font-style: italic;
        }
        .error {
            color: #dc3545;
            background: #f8d7da;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Document to HTML Converter with RCMP/GRC & Canadian Text Processing</h1>
        <p>Paste content from Word (DOCX, DOC), PDF, ODT, RTF, and TXT documents directly into the text area below. The tool will automatically convert and clean the content to HTML, preserve safe styling, sanitize dangerous elements, and automatically wrap RCMP and GRC with abbreviation tags. It also formats times, numbers, and Canadian provinces/territories.</p>
        
        <div class="paste-info">
            <strong>üìã How to use:</strong>
            <ul style="margin: 10px 0; padding-left: 20px;">
                <li><strong>Word Documents:</strong> Open your DOCX/DOC file, select all (Ctrl+A), copy (Ctrl+C), then paste here</li>
                <li><strong>PDF Files:</strong> Open PDF, select and copy text, then paste here</li>
                <li><strong>Other Documents:</strong> Copy content from ODT, RTF, or TXT files and paste here</li>
                <li><strong>Web Content:</strong> Copy HTML content from web pages and paste here</li>
            </ul>
            <div class="supported-formats">
                ‚úÖ Supports pasted content from: Word (DOCX, DOC), PDF, ODT, RTF, TXT, and HTML sources<br>
                ‚úÖ Automatically formats: Times (a.m./p.m. ‚Üí am/pm), Numbers (adds non-breaking spaces), Canadian provinces/territories
            </div>
        </div>
        
        <div class="label">üìù Paste Content Here:</div>
        <div class="paste-area">
        <textarea id="htmlInput" placeholder="Paste your content here from Word, PDF, or any document... 

Try pasting:
- Content copied from a Word document (preserves formatting)
- Text selected and copied from a PDF
- Content from web pages (HTML)
- Text from any other document type

The tool will automatically detect and convert your pasted content!">
This is a test with RCMP and GRC mentioned at 3:30 a.m. and 2:15 p.m.
<p>The <strong>RCMP</strong> reported on <em>GRC</em> activities in ON and QC.</p>
<h2 style="color: blue;">Meeting scheduled for 10 a.m. in BC</h2>
<p style="color: red; font-weight: bold;">Report from AB at 4:30 p.m.</p>
<ul>
  <li>First item with RCMP at 9:15 a.m. in NS</li>
  <li>Second item with GRC at 1:45 p.m. in NB</li>
  <li>Document 123 from SK office</li>
  <li>File 456 from MB department</li>
</ul>
<a href="https://example.com">Safe link</a>
<script>alert('malicious');</script>
<abbr>RCMP</abbr> is already wrapped.
<blockquote>Quote with <span style="background-color: yellow;">highlighted text</span> from NT at 11:30 a.m.</blockquote>
Some more RCMP text here from YT and NU offices.
French text: Rapport du GRC de QC (Qu√©bec) √† 14 h 30.
        </textarea>
        </div>
        
        <button onclick="processHTML()">üîÑ Convert & Process Content</button>
        <button onclick="clearAll()">üóëÔ∏è Clear All</button>
        
        <div class="label">Sanitized Output:</div>
        <div id="output" class="output"></div>
        
        <div class="label">Raw HTML:</div>
        <div id="rawOutput" class="output" style="font-family: monospace; font-size: 12px;"></div>
    </div>

    <script>
        // Enhanced paste event handler to detect and process different content types
        document.getElementById('htmlInput').addEventListener('paste', function(e) {
            // Small delay to allow paste to complete, then process
            setTimeout(function() {
                autoDetectAndProcess();
            }, 100);
        });
        
        // Auto-detect content type and enhance if needed
        function autoDetectAndProcess() {
            const textarea = document.getElementById('htmlInput');
            let content = textarea.value;
            
            // Skip if content is empty or very short
            if (!content || content.trim().length < 10) {
                return;
            }
            
            // Detect and enhance different content types
            if (isProbablyPlainText(content)) {
                content = enhancePlainText(content);
                textarea.value = content;
            } else if (isProbablyWordContent(content)) {
                content = enhanceWordContent(content);
                textarea.value = content;
            } else if (isProbablyPdfContent(content)) {
                content = enhancePdfContent(content);
                textarea.value = content;
            }
            
            // Auto-process after a short delay if content was enhanced
            setTimeout(function() {
                if (textarea.value !== content) {
                    processHTML();
                }
            }, 500);
        }
        
        // Detect if content is likely plain text
        function isProbablyPlainText(content) {
            // Check if content has no HTML tags and has line breaks
            const hasNoHtmlTags = !/<[^>]+>/g.test(content);
            const hasLineBreaks = content.includes('\n');
            const hasMultipleLines = content.split('\n').length > 2;
            
            return hasNoHtmlTags && (hasLineBreaks || hasMultipleLines);
        }
        
        // Detect if content is likely from Word (has specific patterns)
        function isProbablyWordContent(content) {
            // Look for Word-specific patterns
            const wordPatterns = [
                /mso-/i,  // Microsoft Office styles
                /class="?Mso/i,  // Word CSS classes
                /style="[^"]*font-family:[^"]*"/i,  // Inline font styles
                /<p class="?Mso/i,  // Word paragraph classes
                /<!--\[if /i,  // Conditional comments
                /xmlns:w=/i,  // Word XML namespace
                /<w:/i  // Word XML tags
            ];
            
            return wordPatterns.some(pattern => pattern.test(content));
        }
        
        // Detect if content is likely from PDF
        function isProbablyPdfContent(content) {
            // PDF content often has specific characteristics
            const pdfPatterns = [
                /^[A-Z\s]+$/m,  // Lines with all caps (common in PDFs)
                /\s{3,}/g,  // Multiple spaces (PDF formatting artifacts)
                /\n\s*\n\s*\n/g,  // Multiple blank lines
                /^\d+\s*$/m,  // Standalone numbers (page numbers)
                /\s+\d+\s*$/m  // Trailing page numbers
            ];
            
            const hasNoHtmlTags = !/<[^>]+>/g.test(content);
            const hasMultipleLines = content.split('\n').length > 5;
            const hasPdfPatterns = pdfPatterns.some(pattern => pattern.test(content));
            
            return hasNoHtmlTags && hasMultipleLines && hasPdfPatterns;
        }
        
        // Enhance plain text content
        function enhancePlainText(content) {
            return content
                // Convert double line breaks to paragraph breaks
                .split('\n\n')
                .filter(para => para.trim())
                .map(para => {
                    para = para.trim();
                    // Check if it looks like a heading (short line, often caps or title case)
                    if (para.length < 100 && /^[A-Z]/.test(para) && !para.includes('.') && !para.includes(',')) {
                        // Determine heading level based on content
                        if (para.length < 30 && para.toUpperCase() === para) {
                            return `<h2>${para}</h2>`;
                        } else if (para.length < 50) {
                            return `<h3>${para}</h3>`;
                        }
                    }
                    // Convert single line breaks to <br> tags within paragraphs
                    const formattedPara = para.replace(/\n/g, '<br>');
                    return `<p>${formattedPara}</p>`;
                })
                .join('\n');
        }
        
        // Enhance Word content (already has some HTML but may need cleaning)
        function enhanceWordContent(content) {
            // Clean up common Word artifacts
            return content
                // Remove Word-specific conditional comments
                .replace(/<!--\[if [^>]+\]>[\s\S]*?<!\[endif\]-->/gi, '')
                // Clean up excessive Word styling
                .replace(/class="?Mso[^"]*"?/gi, '')
                // Remove empty paragraphs with only non-breaking spaces
                .replace(/<p[^>]*>(?:&nbsp;|\s)*<\/p>/gi, '')
                // Clean up font-family declarations (keep basic ones)
                .replace(/font-family:[^;]*;/gi, (match) => {
                    if (match.includes('Arial') || match.includes('Times') || match.includes('Helvetica')) {
                        return match;
                    }
                    return '';
                })
                // Remove Word XML namespaces
                .replace(/xmlns:\w+="[^"]*"/gi, '')
                // Remove Word-specific tags
                .replace(/<\/?w:[^>]*>/gi, '')
                // Clean up extra whitespace
                .replace(/\s+/g, ' ');
        }
        
        // Enhance PDF content
        function enhancePdfContent(content) {
            return content
                // Remove excessive whitespace
                .replace(/\s{3,}/g, ' ')
                // Remove standalone page numbers
                .replace(/^\s*\d+\s*$/gm, '')
                // Convert multiple line breaks to paragraph breaks
                .split(/\n\s*\n\s*\n/)
                .filter(section => section.trim())
                .map(section => {
                    // Split section into potential paragraphs
                    const paragraphs = section.split(/\n\s*\n/).filter(p => p.trim());
                    return paragraphs.map(para => {
                        para = para.trim().replace(/\n/g, ' ');
                        // Check if it looks like a heading
                        if (para.length < 100 && /^[A-Z]/.test(para) && !para.includes('.') && para.split(' ').length < 10) {
                            return `<h3>${para}</h3>`;
                        }
                        return `<p>${para}</p>`;
                    }).join('\n');
                })
                .join('\n');
        }

        // Canadian provinces and territories mapping
        const provinceMapping = {
            // English provinces
            'AB': 'Alberta',
            'BC': 'British Columbia',
            'MB': 'Manitoba',
            'NB': 'New Brunswick',
            'NL': 'Newfoundland and Labrador',
            'NS': 'Nova Scotia',
            'ON': 'Ontario',
            'PE': 'Prince Edward Island',
            'QC': 'Quebec',
            'SK': 'Saskatchewan',
            'NT': 'Northwest Territories',
            'NU': 'Nunavut',
            'YT': 'Yukon',
            // French provinces (with French names)
            'QC_FR': 'Qu√©bec',
            'NB_FR': 'Nouveau-Brunswick',
            'ON_FR': 'Ontario',
            'MB_FR': 'Manitoba',
            'AB_FR': 'Alberta',
            'BC_FR': 'Colombie-Britannique',
            'SK_FR': 'Saskatchewan',
            'NS_FR': 'Nouvelle-√âcosse',
            'PE_FR': '√éle-du-Prince-√âdouard',
            'NL_FR': 'Terre-Neuve-et-Labrador',
            'NT_FR': 'Territoires du Nord-Ouest',
            'NU_FR': 'Nunavut',
            'YT_FR': 'Yukon'
        };

        // Function to detect if text is likely French
        function isFrenchContext(text) {
            const frenchWords = ['le', 'la', 'les', 'de', 'du', 'des', 'et', '√†', 'dans', 'sur', 'avec', 'pour', 'par', 'rapport', 'bureau', 'province', 'territoire', 'GRC'];
            const words = text.toLowerCase().split(/\s+/);
            const frenchWordCount = words.filter(word => frenchWords.includes(word)).length;
            return frenchWordCount >= 2 || text.includes('GRC');
        }

        // Function to apply Canadian text formatting
        function applyCanadianFormatting(html) {
            // Create a temporary div to work with the DOM
            const temp = document.createElement('div');
            temp.innerHTML = html;
            
            // Function to process text nodes
            function processTextNode(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    let text = node.textContent;
                    let originalText = text;
                    
                    // 1. Add non-breaking space before numbers with space before and after
                    text = text.replace(/(\s)(\d+)(\s)/g, '$1&nbsp;$2$3');
                    
                    // 2. Change a.m./p.m. to am/pm
                    text = text.replace(/(\d+):(\d+)\s*a\.m\./gi, '$1:$2 am');
                    text = text.replace(/(\d+):(\d+)\s*p\.m\./gi, '$1:$2 pm');
                    text = text.replace(/(\d+)\s*a\.m\./gi, '$1 am');
                    text = text.replace(/(\d+)\s*p\.m\./gi, '$1 pm');
                    
                    // 3. Handle Canadian provinces and territories
                    // Get surrounding context to determine if French
                    const parentText = node.parentNode ? node.parentNode.textContent : text;
                    const isFrench = isFrenchContext(parentText);
                    
                    // Replace province abbreviations
                    Object.keys(provinceMapping).forEach(abbrev => {
                        if (abbrev.endsWith('_FR')) return; // Skip French keys for now
                        
                        const pattern = new RegExp(`\\b${abbrev}\\b`, 'g');
                        if (pattern.test(text)) {
                            if (isFrench) {
                                // Use French name with parentheses
                                const frenchKey = abbrev + '_FR';
                                const frenchName = provinceMapping[frenchKey] || provinceMapping[abbrev];
                                text = text.replace(pattern, `, ${frenchName} (${provinceMapping[abbrev]})`);
                            } else {
                                // Use English name with comma
                                text = text.replace(pattern, `, ${provinceMapping[abbrev]}`);
                            }
                        }
                    });
                    
                    if (text !== originalText) {
                        // Create a new element to hold the processed HTML
                        const wrapper = document.createElement('span');
                        wrapper.innerHTML = text;
                        
                        // Replace the text node with the new content
                        const parent = node.parentNode;
                        while (wrapper.firstChild) {
                            parent.insertBefore(wrapper.firstChild, node);
                        }
                        parent.removeChild(node);
                    }
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    // Recursively process child nodes
                    const children = Array.from(node.childNodes);
                    children.forEach(child => processTextNode(child));
                }
            }
            
            // Process all nodes
            const allNodes = Array.from(temp.childNodes);
            allNodes.forEach(node => processTextNode(node));
            
            return temp.innerHTML;
        }

        // HTML sanitization function - preserves structural elements and safe styling
        function sanitizeHTML(html) {
            // Create a temporary div to parse HTML
            const temp = document.createElement('div');
            temp.innerHTML = html;
            
            // Define allowed structural elements (these will be preserved)
            const allowedElements = [
                'p', 'div', 'span', 'br', 'hr',
                'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 
                'strong', 'b', 'em', 'i', 'u', 'strike', 'del', 'ins', 'sub', 'sup',
                'ul', 'ol', 'li', 'dl', 'dt', 'dd',
                'table', 'thead', 'tbody', 'tfoot', 'tr', 'td', 'th', 'caption',
                'a', 'abbr', 'acronym', 'address', 'cite', 'code', 'kbd', 'pre', 'samp', 'var',
                'blockquote', 'q', 'small', 'big', 'tt',
                'img', 'figure', 'figcaption'
            ];
            
            // Remove dangerous elements (everything not in allowed list that could be dangerous)
            const dangerousElements = temp.querySelectorAll('script, iframe, object, embed, form, input, button, select, textarea, link[rel="stylesheet"], style, meta, base, frame, frameset, noframes, applet, area, map, noscript, canvas, audio, video, source, track');
            dangerousElements.forEach(el => el.remove());
            
            // Remove elements that are not in the allowed list (but preserve their content)
            const allElements = Array.from(temp.querySelectorAll('*'));
            allElements.forEach(el => {
                const tagName = el.tagName.toLowerCase();
                
                // If element is not allowed and not already removed, unwrap it (keep content, remove tag)
                if (!allowedElements.includes(tagName) && el.parentNode) {
                    // Move all child nodes to the parent before removing the element
                    while (el.firstChild) {
                        el.parentNode.insertBefore(el.firstChild, el);
                    }
                    el.parentNode.removeChild(el);
                }
            });
            
            // Process remaining allowed elements
            const remainingElements = temp.querySelectorAll('*');
            remainingElements.forEach(el => {
                // Remove dangerous event attributes
                const dangerousAttrs = [
                    'onclick', 'onload', 'onerror', 'onmouseover', 'onfocus', 'onblur', 
                    'onchange', 'onsubmit', 'onmouseout', 'onkeydown', 'onkeyup', 'onkeypress',
                    'onmousedown', 'onmouseup', 'onmousemove', 'onmouseenter', 'onmouseleave',
                    'ondblclick', 'oncontextmenu', 'onwheel', 'ondrag', 'ondrop', 'onscroll',
                    'onresize', 'onselect', 'onunload', 'onbeforeunload'
                ];
                dangerousAttrs.forEach(attr => {
                    if (el.hasAttribute(attr)) {
                        el.removeAttribute(attr);
                    }
                });
                
                // Sanitize href attributes (keep safe links)
                if (el.hasAttribute('href')) {
                    const href = el.getAttribute('href');
                    if (href.toLowerCase().startsWith('javascript:') || 
                        href.toLowerCase().startsWith('data:') || 
                        href.toLowerCase().startsWith('vbscript:')) {
                        el.removeAttribute('href');
                    }
                }
                
                // Sanitize src attributes (keep safe images)
                if (el.hasAttribute('src')) {
                    const src = el.getAttribute('src');
                    if (src.toLowerCase().startsWith('javascript:') || 
                        src.toLowerCase().startsWith('vbscript:')) {
                        el.removeAttribute('src');
                    }
                    // Allow data: URLs for images (common in Word documents)
                    // but could be restricted if needed
                }
                
                // Clean up style attributes while preserving safe styling
                if (el.hasAttribute('style')) {
                    const style = el.getAttribute('style');
                    // Remove potentially dangerous CSS properties
                    const cleanStyle = style
                        .replace(/expression\s*\(/gi, '') // Remove CSS expressions
                        .replace(/javascript:/gi, '') // Remove javascript URLs
                        .replace(/vbscript:/gi, '') // Remove vbscript URLs
                        .replace(/@import/gi, '') // Remove @import
                        .replace(/behavior\s*:/gi, '') // Remove IE behaviors
                        .replace(/binding\s*:/gi, ''); // Remove XML binding
                    el.setAttribute('style', cleanStyle);
                }
                
                // Preserve class attributes (Word documents often use these)
                if (el.hasAttribute('class')) {
                    const classNames = el.getAttribute('class');
                    // Remove quotes but keep the classes
                    const cleanClasses = classNames.replace(/['"]/g, '').trim();
                    if (cleanClasses) {
                        el.setAttribute('class', cleanClasses);
                    } else {
                        el.removeAttribute('class');
                    }
                }
                
                // Clean up other common Word document attributes
                const wordAttrs = ['lang', 'xml:lang', 'dir'];
                wordAttrs.forEach(attr => {
                    if (el.hasAttribute(attr)) {
                        // Keep these attributes as they're generally safe
                        const value = el.getAttribute(attr);
                        if (!value || value.trim() === '') {
                            el.removeAttribute(attr);
                        }
                    }
                });
                
                // Remove empty attributes
                Array.from(el.attributes).forEach(attr => {
                    if (attr.value.trim() === '') {
                        el.removeAttribute(attr.name);
                    }
                });
            });
            
            return temp.innerHTML;
        }
        
        // Function to wrap RCMP and GRC with abbr tags
        function wrapAbbreviations(html) {
            // Create a temporary div to work with the DOM
            const temp = document.createElement('div');
            temp.innerHTML = html;
            
            // Function to process text nodes
            function processTextNode(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    let text = node.textContent;
                    
                    // Replace RCMP and GRC that are not already inside abbr tags
                    // Use word boundaries to match whole words only
                    text = text.replace(/\b(RCMP|GRC)\b/g, (match) => {
                        return `<abbr>${match}</abbr>`;
                    });
                    
                    if (text !== node.textContent) {
                        // Create a new element to hold the processed HTML
                        const wrapper = document.createElement('span');
                        wrapper.innerHTML = text;
                        
                        // Replace the text node with the new content
                        const parent = node.parentNode;
                        while (wrapper.firstChild) {
                            parent.insertBefore(wrapper.firstChild, node);
                        }
                        parent.removeChild(node);
                    }
                } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() !== 'abbr') {
                    // Recursively process child nodes, but skip if already inside an abbr tag
                    const children = Array.from(node.childNodes);
                    children.forEach(child => processTextNode(child));
                }
            }
            
            // Process all nodes
            const allNodes = Array.from(temp.childNodes);
            allNodes.forEach(node => processTextNode(node));
            
            return temp.innerHTML;
        }

        
        // Main processing function
        function processHTML() {
            const input = document.getElementById('htmlInput').value;
            const output = document.getElementById('output');
            const rawOutput = document.getElementById('rawOutput');
            
            if (!input.trim()) {
                output.innerHTML = '<em>No input provided</em>';
                rawOutput.innerHTML = '<em>No input provided</em>';
                return;
            }
            
            try {
                // First sanitize the HTML (preserving safe styling)
                let sanitized = sanitizeHTML(input);
                
                // Apply Canadian text formatting (times, numbers, provinces)
                let formatted = applyCanadianFormatting(sanitized);
                
                // Then wrap RCMP and GRC with abbreviation tags
                let processed = wrapAbbreviations(formatted);
                
                // Display the results
                output.innerHTML = processed;
                rawOutput.textContent = processed;
                
            } catch (error) {
                output.innerHTML = '<em style="color: red;">Error processing HTML: ' + error.message + '</em>';
                rawOutput.innerHTML = '<em style="color: red;">Error processing HTML</em>';
            }
        }
        
        // Clear function
        function clearAll() {
            document.getElementById('htmlInput').value = '';
            document.getElementById('output').innerHTML = '';
            document.getElementById('rawOutput').innerHTML = '';
        }
        
        // Process the default content on page load
        window.onload = function() {
            processHTML();
        };
    </script>
</body>
</html>
